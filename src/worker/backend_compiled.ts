
/* COMPILED WORKER */

export default '(()=>{const i=(()=>{const e=typeof postMessage=="function";if(e){const t=globalThis;return{on:(n,r)=>{t.addEventListener(n,d=>{r(d.data)})},send:n=>{t.postMessage(n)}}}else{const t=require("worker_threads").parentPort;return{on:(n,r)=>{t.on(n,r)},send:n=>{t.postMessage(n)}}}})(),o={methods:{},exec:(e,t)=>{const n=o.methods[e],r={require:globalThis.require},d=new Promise(s=>s(n.apply(r,t))),g=s=>{try{i.send({type:"result",value:s})}catch(c){a(c)}},a=s=>{s=s instanceof Error?s:typeof s=="string"?new Error(s):new Error;const{message:c,name:u,stack:p}=s;i.send({type:"result",error:{message:c,name:u,stack:p}})};d.then(g,a)},init:e=>{o.register(e),i.send({type:"ready"})},message:e=>{if(e.type==="init")return o.init(e.methods);if(e.type==="exec")return o.exec(e.method,e.args)},register:e=>{if(typeof e=="string"){const t=new Function(e)();for(const n in t)o.methods[n]=t[n]}else for(const t in e){const n=new Function(`return (${e[t]})`)();o.methods[t]=n}}};i.on("message",o.message);})();';
